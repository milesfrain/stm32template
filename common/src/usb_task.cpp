/*
 * Wrapper for a USB instance.
 * Provides read() and write() interfaces.
 * Statically allocates one tx task and two stream buffers.
 * Rx is interrupt-based.
 */

#include "usb_task.h"
#include "basic.h"
#include "logging.h"
#include "usbd_cdc.h"
#include "usbd_core.h"
#include "usbd_desc.h"

// ------- For C-style callbacks --------

// Going with a singleton approach
static UsbTask* singleton = nullptr;

int8_t initWrap(void)
{
  return singleton->initCb();
}
int8_t deInitWrap(void)
{
  return singleton->deInitCb();
}
int8_t controlWrap(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  return singleton->controlCb(cmd, pbuf, length);
}
// Assuming the pointer to len is to allow us to do a partial read.
int8_t receiveWrap(uint8_t* buf, uint32_t* len)
{
  return singleton->receiveCb(buf, len);
}
// Not sure what pointer to len is for here. Do we expect a partial
// transmit that's also "complete"?
int8_t transmitCpltWrap(uint8_t* buf, uint32_t* len, uint8_t epnum)
{
  return singleton->transmitCpltCb(buf, len, epnum);
}

// C-style wrapper to enable launching C++ class member functions in rtos
// as task entry points.
void txFuncWrapper(UsbTask* p)
{
  p->txFunc();
}
void rxFuncWrapper(UsbTask* p)
{
  p->rxFunc();
}

// ------- API ---------

// Constructor
UsbTask::UsbTask(UBaseType_t priority)
  : txTask{ "usb_tx", txFuncWrapper, this, priority }
  , callbacks{ initWrap, deInitWrap, controlWrap, receiveWrap, transmitCpltWrap }
  , txLen{ 0 }
{
  if (singleton != nullptr) {
    error("UsbTask singleton already created");
  } else {
    singleton = this;
  }

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&usbDeviceHandle, &FS_Desc, DEVICE_FS) != USBD_OK) {
    error("UsbTask failed USBD_Init");
  }
  if (USBD_RegisterClass(&usbDeviceHandle, &USBD_CDC) != USBD_OK) {
    error("UsbTask failed USBD_RegisterClass");
  }
  if (USBD_CDC_RegisterInterface(&usbDeviceHandle, &callbacks) != USBD_OK) {
    error("UsbTask failed USBD_RegisterInterface");
  }
  if (USBD_Start(&usbDeviceHandle) != USBD_OK) {
    error("UsbTask failed USBD_Start");
  }
}

// Blocking read and write

size_t UsbTask::read(uint8_t* buf, size_t len, TickType_t ticks)
{
  return xStreamBufferReceive(rxMsgBuf.handle, buf, len, ticks);
}

size_t UsbTask::write(const uint8_t* buf, size_t len, TickType_t ticks)
{
  return xStreamBufferSend(txMsgBuf.handle, buf, len, ticks);
}

// ---------- Internal details -------------

void UsbTask::txFunc()
{
  while (1) {
    // Wait until new data to send is available on buffer
    txLen = xStreamBufferReceive(txMsgBuf.handle, txBuf, sizeof(txBuf), portMAX_DELAY);

    // Check if transfer is still in-progress
    if (((USBD_CDC_HandleTypeDef*)(usbDeviceHandle.pClassData))->TxState != 0) {
      // USB busy - this should not happen if notifications are setup correctly
      error("USB unexpectedly busy");
    }

    // Setup transmit
    USBD_CDC_SetTxBuffer(&usbDeviceHandle, txBuf, txLen);
    uint8_t result = USBD_CDC_TransmitPacket(&usbDeviceHandle);
    static LogMsg msg;
    if (result != USBD_OK) {
      do {
        // report error
        itmPrintf(msg, "USB failed to transmit %d\r\n", result);
        osDelay(1);
        // try again
        result = USBD_CDC_TransmitPacket(&usbDeviceHandle);
      } while (result != USBD_OK);
      // report success
      itmPrintf(msg, "USB finally succeeded\r\n");
    }

    // Wait until transfer is complete.
    // Will be signaled from transmitCpltCb ISR.
    // Clear notification value upon receipt and block forever.
    uint32_t bytesSent = ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    if (bytesSent != txLen) {
      itmPrintf(msg, "Only sent %d of %d bytes\r\n", bytesSent, txLen);
    }
  }
}

// ---- Callbacks -----
// Most function comments are from autogenerated usbd_cdc_if.c

/**
 * @brief  Initializes the CDC media low layer over the FS USB IP
 * @retval USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::initCb(void)
{
  // Set buffers
  USBD_CDC_SetTxBuffer(&usbDeviceHandle, txBuf, 0);
  USBD_CDC_SetRxBuffer(&usbDeviceHandle, rxBuf);
  return USBD_OK;
}

/**
 * @brief  DeInitializes the CDC media low layer
 * @retval USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::deInitCb(void)
{
  // do nothing
  return USBD_OK;
}

/**
 * @brief  Manage the CDC class requests
 * @param  cmd: Command code
 * @param  pbuf: Buffer containing command data (request parameters)
 * @param  length: Number of data to be sent (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::controlCb(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  // do nothing
  return USBD_OK;
}

/**
 * @brief  Data received over USB OUT endpoint are sent over CDC interface
 *         through this function.
 *
 *         @note
 *         This function will issue a NAK packet on any OUT packet received on
 *         USB endpoint until exiting this function. If you exit this function
 *         before transfer is complete on CDC interface (ie. using DMA controller)
 *         it will result in receiving more data while previous ones are still
 *         not sent.
 *
 * @param  buf: Buffer of data to be received
 * @param  len: Number of data received (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::receiveCb(uint8_t* buf, uint32_t* len)
{
  // Performing a copy in here is somewhat sub-optimal for an ISR.
  // We could do ping-pong buffers (or similar for improved performance).
  // Made this a lower priority (higher number) ISR to compensate.

  BaseType_t xHigherPriorityTaskWoken = pdFALSE;

  // Check how much data we can copy into the stream buffer
  size_t spaces = xStreamBufferSpacesAvailable(rxMsgBuf.handle);
  if (spaces == 0) {
    // no space, do nothing
  } else if (spaces < *len) {
    // not enough space, but copy as much as we can
    xStreamBufferSendFromISR(rxMsgBuf.handle, buf, spaces, &xHigherPriorityTaskWoken);
    // Shift out transfered bytes
    *len -= spaces;
    memmove(buf, buf + spaces, *len);
    USBD_CDC_SetRxBuffer(&usbDeviceHandle, buf + *len);
    USBD_CDC_ReceivePacket(&usbDeviceHandle);
  } else {
    // plenty of space, copy all of it
    xStreamBufferSendFromISR(rxMsgBuf.handle, buf, *len, &xHigherPriorityTaskWoken);
    *len = 0;
    // Request next packet
    USBD_CDC_SetRxBuffer(&usbDeviceHandle, buf);
    USBD_CDC_ReceivePacket(&usbDeviceHandle);
  }

  // If another task was waiting on data, then trigger context switch
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);

  return USBD_OK;
}

/**
 * @brief  CDC_TransmitCplt_FS
 *         Data transmited callback
 *
 *         @note
 *         This function is IN transfer complete callback used to inform user that
 *         the submitted Data is successfully sent over USB.
 *
 * @param  buf: Buffer of data that was transmitted
 * @param  len: Number of bytes of data transmitted
 * @param  epnum: Endpoint number (don't think we should expect more than one endpoint)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */

int8_t UsbTask::transmitCpltCb(uint8_t* buf, uint32_t* len, uint8_t epnum)
{
  UNUSED(epnum);

  // USB library API questions:
  // Do we expect any partial transfers?
  // Do we need to update *len? If not, then why is it passed as a pointer?

  // Check how much data we were able to transmit
  if (*len == txLen) {
    // We were able to transmit everything.
  } else {
    // We couldn't transmit everything.
    // This sometimes happens.
    // More investigation into USB library required.
  }
  // Always notify, even for failures.
  // Send length for comparison and logging this issue outside of ISR.
  isrTaskNotifyBits(txTask.handle, *len);

  return USBD_OK;
}

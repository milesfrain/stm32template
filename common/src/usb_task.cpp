/*
 * Wrapper for a USB instance.
 * Provides read() and write() interfaces.
 * Statically allocates one tx task and two stream buffers.
 * Rx is interrupt-based.
 */

#include "usb_task.h"
#include "board_defs.h"
#include "catch_errors.h"
#include "itm_logging.h"
#include "usbd_core.h"
#include "usbd_desc.h"

// ------- For C-style callbacks --------

// Going with a singleton approach
static UsbTask* singleton = nullptr;

int8_t initWrap(void)
{
  return singleton->initCb();
}
int8_t deInitWrap(void)
{
  return singleton->deInitCb();
}
int8_t controlWrap(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  return singleton->controlCb(cmd, pbuf, length);
}
// Assuming the pointer to len is to allow us to do a partial read.
// Upon further review, the length pointer appears to be bad API design.
// So we should just treat it as a read-only value.
int8_t receiveWrap(uint8_t* buf, uint32_t* len)
{
  return singleton->receiveCb(buf, len);
}
// Not sure what pointer to len is for here. Do we expect a partial
// transmit that's also "complete"?
int8_t transmitCpltWrap(uint8_t* buf, uint32_t* len, uint8_t epnum)
{
  return singleton->transmitCpltCb(buf, len, epnum);
}

// C-style wrapper to enable launching C++ class member functions in rtos
// as task entry points.
void txFuncWrapper(UsbTask* p)
{
  p->txFunc();
}

// ------- API ---------

// Constructor
UsbTask::UsbTask( //
  TaskUtilitiesArg& utilArg,
  UBaseType_t priority)
  : txTask{ "usb_tx", txFuncWrapper, this, priority }
  , callbacks{ initWrap, deInitWrap, controlWrap, receiveWrap, transmitCpltWrap }
  , util{ utilArg }
{
  if (singleton != nullptr) {
    error("UsbTask singleton already created");
  } else {
    singleton = this;
  }

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&usbDeviceHandle, &FS_Desc, DEVICE_FS) != USBD_OK) {
    error("UsbTask failed USBD_Init");
  }
  if (USBD_RegisterClass(&usbDeviceHandle, &USBD_CDC) != USBD_OK) {
    error("UsbTask failed USBD_RegisterClass");
  }
  if (USBD_CDC_RegisterInterface(&usbDeviceHandle, &callbacks) != USBD_OK) {
    error("UsbTask failed USBD_RegisterInterface");
  }
  if (USBD_Start(&usbDeviceHandle) != USBD_OK) {
    error("UsbTask failed USBD_Start");
  }
}

// Blocking read and write

size_t UsbTask::read(void* buf, size_t len, TickType_t ticks)
{
  return rxMsgBuf.read(buf, len, ticks);
}

size_t UsbTask::write(const void* buf, size_t len, TickType_t ticks)
{
  return txMsgBuf.write(buf, len, ticks);
}

// ---------- Internal details -------------

void UsbTask::txFunc()
{
  util.watchdogRegisterTask();

  while (1) {

    util.watchdogKick();

    // Wait until new data to send is available on buffer
    txLen = util.readAll(txMsgBuf, txBuf, sizeof(txBuf));

    // Don't attempt to transmit if there's no data to transmit
    if (!txLen) {
      continue;
    }

    // Don't attempt to transmit if we haven't received any RX data yet.
    if (!rxReceivedTotal) {
      util.logln( //
        "%s skipping transmit because no link detected (would block forever otherwise)",
        pcTaskGetName(txTask.handle));
      continue;
    }

    // Check if transfer is still in-progress
    while (((USBD_CDC_HandleTypeDef*)(usbDeviceHandle.pClassData))->TxState != 0) {
      // USB busy - this should not happen if notifications are setup correctly
      error("USB unexpectedly busy");
      // util.warnln("USB unexpectedly busy");
      // osDelay(1);
    }

    // Setup transmit
    USBD_CDC_SetTxBuffer(&usbDeviceHandle, txBuf, txLen);

    // USBD_CDC_TransmitPacket just starts the transmit.
    // We need to then wait for transmitCpltCb callback to be called,
    // which then notifies this task that the transmit has completed.
    uint8_t txResult;
    while ((txResult = USBD_CDC_TransmitPacket(&usbDeviceHandle)) != USBD_OK) {
      // report error
      util.warnln("USB failed to initiate transmit %d", txResult);
      osDelay(1);
    }

    // Log pending bytes counter via ITM
    txPendingTotal += txLen;
    itmSendValue(ItmPort::UsbBytesOutPending, txPendingTotal);

    // Wait until transfer is complete.
    // Will be signaled from transmitCpltCb ISR.
    // Clear notification value upon receipt.
    // Timeout occasionally for easier detection of this stall
    // location during debugging.
    uint32_t bytesSent;
    while (!(bytesSent = ulTaskNotifyTake(pdTRUE, suggestedTimeoutTicks))) {
      util.watchdogKick();
      timeout();
    }
    if (bytesSent != txLen) {
      util.warnln("Only sent %d of %d bytes", bytesSent, txLen);
    }

    // Log transmitted bytes counter via ITM
    txTransmittedTotal += bytesSent;
    itmSendValue(ItmPort::UsbBytesOutTransmitted, txTransmittedTotal);
  }
}

// ---- Callbacks -----
// Most function comments are from autogenerated usbd_cdc_if.c

/**
 * @brief  Initializes the CDC media low layer over the FS USB IP
 * @retval USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::initCb(void)
{
  // Set buffers
  USBD_CDC_SetTxBuffer(&usbDeviceHandle, txBuf, 0);
  USBD_CDC_SetRxBuffer(&usbDeviceHandle, rxBuf);
  return USBD_OK;
}

/**
 * @brief  DeInitializes the CDC media low layer
 * @retval USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::deInitCb(void)
{
  // do nothing
  return USBD_OK;
}

/**
 * @brief  Manage the CDC class requests
 * @param  cmd: Command code
 * @param  pbuf: Buffer containing command data (request parameters)
 * @param  length: Number of data to be sent (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::controlCb(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
  // do nothing
  return USBD_OK;
}

// Note these comments are from the autogenerated templates, so not super clear.
/**
 * @brief  Data received over USB OUT endpoint are sent over CDC interface
 *         through this function.
 *
 *         @note
 *         This function will issue a NAK packet on any OUT packet received on
 *         USB endpoint until exiting this function. If you exit this function
 *         before transfer is complete on CDC interface (ie. using DMA controller)
 *         it will result in receiving more data while previous ones are still
 *         not sent.
 *
 * @param  buf: Buffer of data to be received
 * @param  len: Number of data received (in bytes)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */
int8_t UsbTask::receiveCb(uint8_t* buf, uint32_t* len)
{
  UsbRxPinHigh();

  // Performing a copy in here is somewhat sub-optimal for an ISR.
  // We could do ping-pong buffers (or similar for improved performance).
  // Made this a lower priority (higher number) ISR to compensate.

  // Also, logging to ITM has potential to block, but shouldn't,
  // unless this same callback happened within 10uS (unlikely).
  // Todo - should still move this to tx task once that becomes
  // non-blocking with watchdog additions.

  // Log received bytes counter via ITM
  rxReceivedTotal += *len;
  itmSendValue(ItmPort::UsbBytesIn, rxReceivedTotal);

  // Check how much data we can copy into the stream buffer
  size_t spaces = xStreamBufferSpacesAvailable(rxMsgBuf.handle);
  if (spaces == 0) {
    // No space. Do nothing and allow data to drop.
    // Note that USBD_CDC_ReceivePacket must still be called,
    // otherwise incoming USB data will be blocked after 16 drops
    // stall all endpoints.
    // nonCritical();
  } else {
    // Space available

    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (spaces < *len) {
      // Not enough space, but copy as much as we can.
      // Going to lose some data, but not as bad as locking-up system.
      xStreamBufferSendFromISR(rxMsgBuf.handle, buf, spaces, &xHigherPriorityTaskWoken);

      // May achieve better packet parsing performance (and overall higher data rates)
      // by eliminating the above line to avoid writing packet fragments that will
      // definitely fail parsing. Downside of no partial write is that we could
      // miss out on any whole packets contained within the partial write.

      // nonCritical();
    } else {
// plenty of space, copy all of it
#if 1
      xStreamBufferSendFromISR(rxMsgBuf.handle, buf, *len, &xHigherPriorityTaskWoken);
#else
      // artificial data loss - occasionally drop the last few bytes
      static uint32_t ndrop = 0;
      ndrop++;
      ndrop %= 4;
      xStreamBufferSendFromISR(rxMsgBuf.handle, buf, *len - ndrop, &xHigherPriorityTaskWoken);
#endif
    }

    // If another task was waiting on data, then trigger context switch
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  }

  // Request next packet.
  USBD_CDC_ReceivePacket(&usbDeviceHandle);

  UsbRxPinLow();

  return USBD_OK;
}

// Note these comments are from the autogenerated templates, so not super clear.
/**
 * @brief  CDC_TransmitCplt_FS
 *         Data transmited callback
 *
 *         @note
 *         This function is IN transfer complete callback used to inform user that
 *         the submitted Data is successfully sent over USB.
 *
 * @param  buf: Buffer of data that was transmitted
 * @param  len: Number of bytes of data transmitted
 * @param  epnum: Endpoint number (don't think we should expect more than one endpoint)
 * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
 */

int8_t UsbTask::transmitCpltCb(uint8_t* buf, uint32_t* len, uint8_t epnum)
{
  // We don't care about endpoint number
  UNUSED(epnum);

  // USB library API questions:
  // Do we expect any partial transfers?
  // Do we need to update *len? If not, then why is it passed as a pointer?

  // Check how much data we were able to transmit
  if (*len == txLen) {
    // We were able to transmit everything.
  } else if (*len == 0) {
    // Zero bytes - shouldn't happen
    critical();
  } else {
    // We couldn't transmit everything.
    // This sometimes happens.
    // More investigation into USB library required.
    // This is reported in txFunc (assuming the notifiy is correctly picked-up).
  }
  // Always notify, even for failures.
  // Send length for comparison and logging this issue outside of ISR.
  isrTaskNotifyBits(txTask.handle, *len);

  return USBD_OK;
}
